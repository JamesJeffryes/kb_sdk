#BEGIN_HEADER
#END_HEADER


class ${module_name}:
    '''
    Module Name:
    ${module_name}
    Module Description:
    
    '''
    
#[[    ######## WARNING FOR GEVENT USERS #######]]#
    # Since asynchronous IO can lead to methods - even the same method -
    # interrupting each other, you must be *very* careful when using global
    # state. A method could easily clobber the state set by another while
    # the latter method is running.
#[[    #########################################]]#
    #BEGIN_CLASS_HEADER
    #END_CLASS_HEADER
    
    # config contains contents of config file in a hash or None if it couldn't
    # be found
    def __init__(self, config):
        #BEGIN_CONSTRUCTOR
        #END_CONSTRUCTOR
        pass

    def count_contigs(self, ctx, workspace_name, contigset_id):
        # ctx is the context object
        # return variables are: returnVal
        #BEGIN count_contigs
        token = ctx['token']
        rpc_context = None
        if 'rpc_context' in ctx:
            rpc_context = ctx['rpc_context']
        returnVal = {'workspace_name': workspace_name, 'contigset_id': contigset_id, \
                     'user': ctx['user_id'], 'rpc_context': rpc_context}
        #END count_contigs
        
        # At some point might do deeper type checking...
        if not isinstance(returnVal, object):
            raise ValueError('Method count_contigs return value ' +
                             'returnVal is not type object as required.')
        # return the results
        return [returnVal]
